using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;

namespace LPO_SAPR
{
    //Реализация структуры хранения данных ВЕКТОР в рамках прохождения дисциплины "Лингвистическое и программное обеспечение САПР"
    //Арсений Ковешников, БИВТ-18-3
    //Кафедра АПД ИТКН НИТУ «МИСиС»

    //объявление класса. Ключевое слово unsafe необходимо для работы с указателями на память.
    //тип данных неуправляемый T, т.к. будет задан уже при объявлении конкретного вектора.
    public unsafe class ArsVector<T> where T : unmanaged
    {
        //ДЕСКРИПТОР ВЕКТОРА
        private T* data; //указатель на поле для хранения данных вектора неопределённого типа. Заданный в дальнейшем тип определит и L - длину элемента.
        private int m; //индекс первого элемента
        private int n; //индекс последнего элемента

        //конструктор класса
        public ArsVector(int _m, int _n)
        {
            data = (T*)Marshal.AllocHGlobal(sizeof(T) * (_n - _m + 1));
            //Marshal - набор методов для ручного управления памятью в C#, которое, как известно, стандартно в этом языке происходит автоматически
            //вручную выделяем (длина элемента * кол-во элементов) памяти и сохраняем ссылку на выделенный участок памяти в поле для хранения указателя на вектор в дескрипторе
            m = _m; //сохраняем индекс первого элемента
            n = _n; //сохраняем индекс последнего элемента
        }

        //декструктор класса
        ~ArsVector()
        {
            Marshal.FreeHGlobal((IntPtr)data); //снова обращаемся к методам Marshal и, обращаясь через указатель, очищаем блок памяти, в котором хранятся данные
        }

        //объявляем индексатор для осуществления доступа к элементу вектора
        public T this[int index]
        {
            //действии при получении данных из вектора по индексу
            get
            {
                //выполняем проверку на выход индекса за границы вектора, если выход обнаружен, выбрасываем ошибку, прерывающую программу
                if (index < m || index > n)
                    throw new IndexOutOfRangeException();

                //в C# выражение *(x+i), где x - указатель на поле данных, а i - индекс, позволяет получить указатель на данные, находящиеся в i*L бит от исходного указателя
                //то есть данное выражение эквивалентно формуле Ai=Am+(i-m)*L
                return *(data + index);
            }

            //действии при задании данных в вектор по индексу
            set
            {
                //выполняем проверку на выход индекса за границы вектора, если выход обнаружен, выбрасываем ошибку, прерывающую программу
                if (index < m || index > n)
                    throw new IndexOutOfRangeException();

                //использовано выражение, аналогичное описанному выше, только теперь значение задаётся
                *(data + index) = value;
            }
        }

        //метод, возвращающий длину вектора
        public int Length()
        {
            return n - m + 1;
        }
    }
}
