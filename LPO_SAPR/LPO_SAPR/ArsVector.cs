using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;

namespace LPO_SAPR
{
    //Реализация структуры хранения данных ВЕКТОР (динамический массив)
    //Арсений Ковешников, БИВТ-18-3
    //Кафедра АПД ИТКН НИТУ «МИСиС»

    //объявление класса. Ключевое слово unsafe необходимо для работы с указателями на память.
    //тип пока что неопределённый T, т.к. будет задан уже при объявлении конкретного вектора.
    public unsafe class ArsVector<T> where T : unmanaged
    {
        //ДЕСКРИПТОР ВЕКТОРА
        private T* data; //указатель на поле для хранения данных вектора неопределённого типа. Заданный в дальнейшем тип определит и L - длину элемента.
        private int m; //индекс первого элемента
        private int n; //индекс последнего элемента

        //private int capacity; //техническое поле "вместимость" для хранения размера памяти, которая зарезервирована под вектор
        //private const int DEF_SIZE = 5; //константа для задания стандартного размера резерва памяти под вектор
        //private const int SIZE_MULT = 2; //константа для хранения множителя расширения резерва памяти

        //конструктор класса
        public ArsVector(int _m, int _n)
        {
            fixed (T* setData = new T[_n-_m+1]) //фиксируем ссылку на участок памяти длиной n-m+1, тем самым выделяя память под вектор
            {
                data = setData; //сохраняем ссылку на выделенный участок памяти в поле дескриптора
                m = _m; //сохраняем индекс первого элемента
                n = _n; //сохраняем индекс последнего элемента
            }
        }

        ~ArsVector()
        {

        }

        //объявляем индексатор для осуществления доступа к элементу вектора
        public T this[int index]
        {
            //действии при получении данных из вектора по индексу
            get
            {
                //выполняем проверку на выход индекса за границы вектора
                if (index < m || index > n)
                    throw new IndexOutOfRangeException();

                //в C# выражение *(x+i), где x - указатель на поле данных, а i - индекс, позволяет получить указатель на данные, находящиеся в i*L бит от исходного указателя
                //то есть данное выражение равноценно формуле Ai=Am+(i-m)*L
                return *(data + index);
            }

            //действии при задании данных в вектор по индексу
            set
            {
                //выполняем проверку на выход индекса за границы вектора
                if (index < m || index > n)
                    throw new IndexOutOfRangeException();

                //использовано выражение, аналогичное описанному выше, только теперь значение задаётся
                *(data + index) = value;
            }
        }

        public int Length()
        {
            return n - m;
        }
    }
}
