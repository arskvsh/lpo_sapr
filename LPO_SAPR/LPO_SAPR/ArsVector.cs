using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;

namespace LPO_SAPR
{
    //Реализация структуры хранения данных ВЕКТОР в рамках прохождения дисциплины "Лингвистическое и программное обеспечение САПР"
    //Арсений Ковешников, БИВТ-18-3
    //Кафедра АПД ИТКН НИТУ «МИСиС»

    //объявление класса. Ключевое слово unsafe необходимо для работы с указателями на память.
    //тип данных неуправляемый T, т.к. будет задан уже при объявлении конкретного вектора.
    public unsafe class ArsVector<T> where T : unmanaged
    {
        //ДЕСКРИПТОР ВЕКТОРА
        private T* data; //указатель на поле для хранения данных вектора неопределённого типа. Заданный в дальнейшем тип определит и L - длину элемента.
        private int m; //индекс первого элемента
        private int n; //индекс последнего элемента

        //конструктор класса
        public ArsVector(int _m, int _n)
        {
            if (_m <= _n)//проверяем, что индекс последнего элемента больше индекса первого, иначе выбрасываем ошибку
            {
                data = (T*)Marshal.AllocHGlobal(sizeof(T) * (_n - _m + 1));
                //вручную выделяем (длина элемента * кол-во элементов) памяти и сохраняем ссылку на выделенный участок памяти в поле для хранения указателя на вектор в дескрипторе
                //замечание: Marshal - набор методов для ручного управления памятью в C#, которое, как известно, по стандарту в этом языке происходит автоматически

                m = _m; //сохраняем индекс первого элемента
                n = _n; //сохраняем индекс последнего элемента
            } else
            {
                throw new IndexOutOfRangeException("Нельзя создать вектор, в котором индекс первого элемента больше индекса последнего!");
            }
        }

        //деструктор класса
        ~ArsVector()
        {
            Marshal.FreeHGlobal((IntPtr)data); //снова обращаемся к методам Marshal и, обращаясь через указатель, очищаем блок памяти, в котором хранятся данные
        }

        //объявляем индексатор для осуществления доступа к элементу вектора
        public T this[int index]
        {
            //действии при получении данных из вектора по индексу
            get
            {
                //выполняем проверку на выход индекса за границы вектора, если выход обнаружен, выбрасываем ошибку, прерывающую программу
                if (index < m || index > n)
                    throw new IndexOutOfRangeException();

                //в C# выражение *(x+i), где x - указатель на поле данных, а i - индекс, позволяет получить указатель на данные, находящиеся в i*L байт от исходного указателя
                //то есть данное выражение смещает указатель на i элементов вправо и оказывается эквивалентным формуле Ai=Am+(i-m)*L
                return *(data + index);
            }

            //действии при задании данных в вектор по индексу
            set
            {
                //выполняем проверку на выход индекса за границы вектора, если выход обнаружен, выбрасываем ошибку, прерывающую программу
                if (index < m || index > n)
                    throw new IndexOutOfRangeException();

                //использовано выражение, аналогичное описанному выше, только теперь значение задаётся
                *(data + index) = value;
            }
        }

        //функция, возвращающая длину вектора
        public int Length()
        {
            return n - m + 1;
        }

        //свойство, возвращающее значение индекса первого элемента
        public int GetFirstIndex
        {
            get
            {
                return m;
            }
        }

        //свойство, возвращающее значение индекса последнего элемента
        public int GetLastIndex
        {
            get
            {
                return n;
            }
        }

        //функция, возвращающая индекс первого включения некоторого искомого значения
        public int IndexOf(T itemToSearch)
        {
            int foundIndex = Int32.MinValue;
            for (int i = this.m; i < (this.n - this.m + 1); i++)
            {
                if(itemToSearch.Equals(this[i]))
                {
                    foundIndex = i;
                    break;
                }
            }

            return foundIndex;
        }
    }
}
